//Script to analyse the overlap of isolectin staining with vessels, splits the image into 3D objects and calculates the length of these vessel objects, their radii, as well as the isolectin overlap for the objects
//Dependencies: 3D Suite, Voxel Counter, morpholibJ
//Written by Devin 9/1/19

import ij.IJ;
import ij.measure.Calibration;
import ij.plugin.Duplicator;
import ij.WindowManager;
import ij.gui.WaitForUserDialog; //Import to allow us to wait for user input
import ij.gui.NonBlockingGenericDialog; //Import to allow us to create non blocking dialogs
import ij.gui.GenericDialog; //Import to allow us to create non blocking dialogs
import ij.plugin.frame.RoiManager;
import ij.gui.Roi;
import ij.plugin.ImageCalculator;
import ij.measure.ResultsTable;
import ij.io.DirectoryChooser; //Import so the user can select a directory from a dialog box
import ij.ImagePlus;
import ij.plugin.ChannelSplitter;
import ij.ImageStack;
import ij.io.FileSaver;
import java.text.SimpleDateFormat;
import java.text.DateFormat;
import ij.process.StackStatistics;

//This is a function to close an image and either save it or not depending on the value of toSave
public static closeImage(ImagePlus image, boolean toSave) {
	image.changes = toSave;
	image.close();
}

//Function to try all the autoThresh options and get user input after making a small substack of the input image
public static autoThreshTryAll(ImagePlus avg) {

 //Using the number of slices in the image, calculate the slice at 40% of the depth and 55% of the depth of the stack
 int[] limits = { (((avg.getDimensions()[3]) * 0.40).intValue()), (((avg.getDimensions()[3])*0.55).intValue()) };
 //[0] is lowerLim, [1] is upperLim

 //ImagePlus array to store the images we'll work with in the function
 ImagePlus[] threshImages = new ImagePlus[2];
 //[0] is threshTest, [1] is threshStack

 //Here we create a 5 slice substack of our smoothed, cleaned image, so that we can try out the auto thresholds on it
 threshImages[0] = new Duplicator().run(avg, lowerLim, upperLim);

 //This runs the try all action for the auto threshold method
 IJ.run(threshImages[0], "Auto Threshold", "method=[Try all] white stack");
 threshImages[1] = WindowManager.getImage("Stack");

 //These string arrays are for choosing which thresholding method to use
 //Each index in threshChoice corresponds to the method in threshNames
 String[] threshChoice = { "1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16" };

 //Create a non-blocking dialog so the user can still check the image whilst choosing
 //Ask the user which threshold option worked best, and also whether none of them are good
 NonBlockingGenericDialog userInputs = new NonBlockingGenericDialog("Auto Threshold Choice");
 userInputs.addChoice("Which panel worked the best?", threshChoice, "1");
 userInputs.addCheckbox("Tick if you're not happy with any of the options", false);

 userInputs.showDialog();

 //Close the stack of threshold test and threshTest image
 for(int i=0; i< threshImages.length; i++) {
 	closeImage(threshImages[i], false);
 }

 //Get the choices from the dialog box and the associted thresholding method
 int choice = userInputs.getNextChoiceIndex() + 1;

 //Get whether the user is happy with the threshold options 
 boolean goodThreshChoice = userInputs.getCheckboxes().get(0).getState();

 //If the user isn't happy with any of the choices, set the threshold selected to 0
 if (goodThreshChoice == true) {
  int choice = 0;
 }

 //Return the thresh selected
 return choice;

}

//This is to replace the image avg with another image backup so that for all variable and title purposes backup is now avg
public static replaceWithBackup(ImagePlus avg, ImagePlus backup) {

 //Get the title of avg, close it without changes, set backup to the same title and reassign it to the avg variable and return it
 backup.setTitle(avg.getTitle());
 closeImage(avg, false);
 avg = backup;
 avg.show();
 return avg;
 
}

//This is to get the user's approval, a simple dialog box with a single check box, and we return the boolean of the checkbox - inputs are just strings for the
//title of the dialog box and the checkbox itself
public static dialogUserApproval(String dialogTitle, String dialogText) {
	
 NonBlockingGenericDialog userInputs = new NonBlockingGenericDialog(dialogTitle);
 userInputs.addCheckbox(dialogText, true);
 userInputs.showDialog();

 //We get a vector of checkbox choices, then get the first checbox choice, then get its state to get the boolean out
 boolean checkboxBoolean = userInputs.getCheckboxes().get(0).getState();
 return checkboxBoolean;
 
}

//A function for the user to edit an image until they are happy with the threshold produced
public static imageEditingFunction(ImagePlus vesselImageProc, String toRename) {

 //Create a backup of the input image that we can revert to during image processing if we want a clean slate
 ImagePlus babyFresh = vesselImageProc.duplicate();

 //This variable is true as long as we want to keep editing our image
 boolean editImage = true;

 //This variable is true if we're happy to analyse the image once editImage is set to false
 boolean forAnalysis = false;

 //While we want to keep editing
 while (editImage == true) {

  //If the user has press escape during the condition, exit the macro
  if (IJ.escapePressed() == true) {
   System.exit();
  }

  //Show the input image
  vesselImageProc.show();

  //Ask the user to choose between these choices
  String[] choiceArray = {"Start from the beginning - remove all image edits","Manually threshold the image","Try an automated thresholding technique",
   "Smooth the image","Despeckle the image","Play around with the image","Abandon this image - move onto the next"};

  NonBlockingGenericDialog userInputs = new NonBlockingGenericDialog("Image Processing");
  userInputs.addChoice("Watchu wanna do 'bout it?", choiceArray, "Start from the beginning - remove all ROI clearances and thresholding");
  userInputs.showDialog();

  int choice = userInputs.getNextChoiceIndex();

  //If we're abandoning the image
  if (choice ==6) {
  	
  	//Close all images and set editImage to false
  	babyFresh.show();
  	IJ.runMacro("run(\"Close All\")");
  	//WindowManager.closeAllWindows();
  	editImage = false;

  //If we want to play around with the image	
  } else if (choice == 5) {

  	//Create a toShow image so the user can see what they had before the freeplay
  	ImagePlus toShow = vesselImageProc.duplicate();
  	toShow.show();

  	//Also create a hidden backup to revert to if the user doesn't want to proceed after freeplay
  	ImagePlus backup = vesselImageProc.duplicate();
  	backup.hide();

    //Messages to add to the dialog box to inform the user about what to do
  	String[] freePlayMessages = {"Process the image as you see fit", "If you wish to proceed with your processed, thresholded image, rename it \"Processed\"",
  		"Else, leave it named as something else", "When thresholding, tick Dark background and uncheck",
  		"the option to calculate it for each image", "Press \"ok\" when done"};

  	//Create a dialog box showing these messages
  	NonBlockingGenericDialog freePlay = new NonBlockingGenericDialog("Freeplay Processing");
	for(int i=0; i<freePlayMessages.length; i++) {
		freePlay.addMessage(freePlayMessages[i]);
	}
	freePlay.showDialog();

  	//Return the processed image - returns null if it doesn't exist
 	ImagePlus processedImage = WindowManager.getImage("Processed");

	//If the processed image doesn't exists
 	if(processedImage==null) {
 		
 		//We replace our input image with the backup image and then close all other images
 		vesselImageProc = replaceWithBackup(vesselImageProc, backup);
 		
 		vesselImageProc.show();
 		IJ.runMacro("imageTitle = getArgument(); selectWindow(imageTitle); close(\"\\\\Others\")", vesselImageProc.getTitle());
 		babyFresh.show();
 		
 		new WaitForUserDialog("Check that babyfresh is shown", "Check").show();

 		babyFresh.hide();
 		vesselImageProc.hide();

    //If the processed image does exist
 	} else {

		//Check if its been properly thresholded
		thresholded = false;
		IJ.resetThreshold(processedImage);
		stats = new StackStatistics(processedImage);
		//stats=processedImage.getStatistics();
		if ((stats.histogram[0]+stats.histogram[255])!=stats.pixelCount){
		    thresholded = false;
		} else {
			thresholded = true;
		}

		//While it hasn't been thresholded, ask the user to threshold it
		while(thresholded == false) {
			new WaitForUserDialog("Thresholding Error", "Threshold Not Applied, Apply Threshold Now").show();
			stats = new StackStatistics(processedImage);
			//stats=processedImage.getStatistics();
			if ((stats.histogram[0]+stats.histogram[255])!=stats.pixelCount){
			    thresholded = false;
			} else {
				thresholded = true;
			}
			IJ.resetThreshold(processedImage);
			
		}

		//show backup and babyfresh so we can close them
		backup.show();
		babyFresh.show();
	
		//Close all windows except the processed image
		IJ.runMacro("selectWindow(\"Processed\"); close(\"\\\\Others\")");
	 		
	 	//If the processed LUT is inverted, invert it the right way
		if(processedImage.isInvertedLut() == true) {
			IJ.run(processedImage, "Invert LUT", "");
		}
	
		//Set our vesselImageProc variable to the processed image, editImage to false, and forAnalysis to true
		vesselImageProc = processedImage;
		vesselImageProc.setTitle(toRename);
		editImage = false;
	 	forAnalysis = true;

 	}

  //If the user wants to despeckle the image
  } else if (choice == 4) {

   //We backup the image, run the despeckle
   ImagePlus backup = vesselImageProc.duplicate();
   IJ.run(vesselImageProc, "Despeckle", "stack");

   //Show the backup so the user can compare the despeckled image to non despeckled
   backup.show();

   //Check user is happy with despeckling, if so then proceed and close the backup, else revert to backup
   boolean despeckleCheck = dialogUserApproval("Despeckling satisfactory?", "Happy with the despeckle?");
   if (despeckleCheck == true) {
    backup.close();
    IJ.log("Image despeckled");
   } else {
    vesselImageProc = replaceWithBackup(vesselImageProc, backup);
   }

   //If the user wants to smooth the image
  } else if (choice == 3) {

   //Backup the image
   ImagePlus backup = vesselImageProc.duplicate();

   //Get the user's choices re: smoothing technique and size of smoothing in terms of pixel sizes
   String[] smoothingArray = {"Gaussian Blur 3D","Median 3D","Mean 3D","Minimum 3D","Maximum 3D","Variance 3D", "Gaussian Blur", "Median", "Mean", "Minimum", "Maximum", "Variance"};
   String[] despeckleArray = {"Yes, before smoothing","Yes, after smoothing","No"};
   String[] pixelSizeArray = {"Pixels to smooth in x: ","Pixels to smooth in y: ","Pixels to smooth in z: "};

   NonBlockingGenericDialog userInputs = new NonBlockingGenericDialog("Image Smoothing");
   userInputs.addChoice("Which smoothing technique?", smoothingArray, "Gaussian Blur 3D");
   userInputs.addChoice("Do you want to despeckle the image?", despeckleArray, "Yes, before smoothing");

   //Add pixel size fields
   for (fields = 0; fields < pixelSizeArray.length; fields++) {
    userInputs.addNumericField(pixelSizeArray[fields], 0, 0);
   }

   userInputs.showDialog();
   ArrayList pixelSizeChoices = new ArrayList();

   //Get pixel sizes
   for (pxls = 0; pxls < pixelSizeArray.length; pxls++) {
    pixelSizeChoices.add(userInputs.getNextNumber());
   }

   //Get the smoothing method and whether to despeckle before, after, or not
   int smoothingMethod = userInputs.getNextChoiceIndex();
   int despeckleMethod = userInputs.getNextChoiceIndex();

   //If we're not using a 3D filter, then the smooth function disregards the z pixel size, otherwise it includes it
   if(smoothingMethod>=6) {
    public static smoothFunction(vesselImageProc, smoothingArray, smoothingMethod, pixelSizeChoices) {IJ.run(vesselImageProc, "" + smoothingArray[smoothingMethod] + "...", "x=" + pixelSizeChoices.get(0) + " y=" + pixelSizeChoices.get(1) + ""); }
   } else {
   	public static smoothFunction(vesselImageProc, smoothingArray, smoothingMethod, pixelSizeChoices) {IJ.run(vesselImageProc, "" + smoothingArray[smoothingMethod] + "...", "x=" + pixelSizeChoices.get(0) + " y=" + pixelSizeChoices.get(1) + " z=" + pixelSizeChoices.get(2) + ""); }
   }

   //If before, run it before smooothing, else run after smoothing
   if (despeckleMethod == 0) {
    IJ.run(vesselImageProc, "Despeckle", "stack");
    smoothFunction(vesselImageProc, smoothingArray, smoothingMethod, pixelSizeChoices);
   } else if (despeckleMethod == 1) {
    smoothFunction(vesselImageProc, smoothingArray, smoothingMethod, pixelSizeChoices);
    IJ.run(vesselImageProc, "Despeckle", "stack");
   } else if (despeckleMethod == 2) {
    smoothFunction(vesselImageProc, smoothingArray, smoothingMethod, pixelSizeChoices);
   }

   //Check user is happy with smoothing, if so then proceed and close the backup, else revert to backup
   boolean smoothFirstCheck = dialogUserApproval("Smoothing satisfactory?", "Happy with the smoothing?");

   if (smoothFirstCheck == true) {
    backup.close();
    IJ.log("Image smoothed using: " + smoothingArray[smoothingMethod]);
    if (despeckleMethod == 1) {
     IJ.log("Image despeckled after smoothing");
    } else if (despeckleMethod == 0) {
     IJ.log("Image despeckled before smoothing");
    }
    IJ.log("Pixel sizes used: " + " x:" + pixelSizeChoices.get(0) + " y:" + pixelSizeChoices.get(1) + " z:" + pixelSizeChoices.get(2));
   } else {
    vesselImageProc = replaceWithBackup(vesselImageProc, backup);
   }

   //If the user chooses to try an automated thresholding technique
  } else if (choice == 2) {

   //Backup the input image and run the autoThreshTryAll function on the input
   ImagePlus backup = vesselImageProc.duplicate();
   int autoThreshFinal = autoThreshTryAll(vesselImageProc);

   //If the user is happy with the threhsolding, then run it (if autothreshfinal is a 0 then the user didn't like any of the outputs)
   if (autoThreshFinal != 0) {

    String[] threshNames = {"Default","Huang","Huang2","Intermodes","IsoData","Li","MaxEntropy","Mean","MinError(I)","Minimum",
     "Moments","Otsu","Percentile","RenyiEntropy","Shanbhag","Triangle"};
 
    //Notice here we run it with a stack histogram, not what we do when trying them (seems to mess with how it gets displayed)
    String[] stackOptions = {"","use_stack_histogram"};
    boolean stackHistogram = dialogUserApproval("Stack Histogram", "Threshold using the stack histogram?");
    int stackChoice = stackHistogram ? 1 : 0;
    IJ.run(vesselImageProc, "Auto Threshold", "method=" + threshNames[(autoThreshFinal - 1)] + " white stack " + stackOptions[stackChoice] + "");

    //Check if the user is happy
    boolean threshFirstCheck = dialogUserApproval("Threshold satisfactory?", "Happy with the threshold?");

    //If so, we try out skeletonising the threhsolded image outside the editing function
    if (threshFirstCheck == true) {

     IJ.log("Proceeding with threshold: " + threshNames[(autoThreshFinal - 1)]);
     boolean editImage = false;
	 boolean forAnalysis = true;
	 backup.close();
	 babyFresh.close();

     //If the user wasn't happy with thresholding the whole stack, replace the thresholded image with the backup
    } else {
     vesselImageProc = replaceWithBackup(vesselImageProc, backup);
    }
    //Similarly if during the autothrestryall function the user didn't approve anything, then we replace the avg image with the backup	
   } else {
    vesselImageProc = replaceWithBackup(vesselImageProc, backup);
   }

   //If the user chooses the manually threhsold the image		
  } else if (choice == 1) {

   //Create a backup
   ImagePlus backup = vesselImageProc.duplicate();

   //Run the manual threshlding function on the input where manualHappy is a boolean about whether the user was happy with the manual thresholding
   boolean manualHappy = manualThresholding(vesselImageProc);

   //If the user is happy, we'll try the skeleton editing function
   if (manualHappy == true) {

    editImage = false;
    forAnalysis = true;
    backup.close();
    babyFresh.close();

    //If the user wasn't happy with manual thresholding initially, replace the thresholded image with the backup
   } else {
    vesselImageProc = replaceWithBackup(vesselImageProc, backup);
   }

   //If the user wants to start from scratch with the image
  } else if (choice == 0) {

   //Replace the input image with the babyfresh backup and create a new babyfresh backup
   vesselImageProc = replaceWithBackup(vesselImageProc, babyFresh);
   babyFresh = vesselImageProc.duplicate();
   IJ.log("Removing all image edits and starting from scratch");
  }

 }

 ArrayList outputs = new ArrayList();
 outputs.add(vesselImageProc);
 outputs.add(forAnalysis);

 return outputs;

}

//Function to check the outputs returned from the imageEditingFunction, inputs are the output file from that function and a file path to where processed files should be saved
public static checkEditingOutput(editingOutput, File processed) {
	
	//If the output wasn't satisfactory from editing the image, we close all windows and create the processed file path so we skip this file in the future - also the ImagePlus object
	//we return is null
	ImagePlus output = null;
	if(editingOutput.get(1) == false) {
		IJ.runMacro("run(\"Close All\")");
		//WindowManager.closeAllWindows();
		processed.mkdirs();	
	
	//If it was successful, we return the image generated by the image editing function
	} else {
		output = editingOutput.get(0);
	}
	return output;
}

//Function for manual thresholding of an image
public static manualThresholding(ImagePlus avg) {

	avg.show();

	thresholded = false;
	
	stats = new StackStatistics(avg);
	//stats=avg.getStatistics();
	if ((stats.histogram[0]+stats.histogram[255])!=stats.pixelCount){
	    thresholded = false;
	    IJ.log("false");
	} else {
		thresholded = true;
	}

	while(thresholded == false) {

		IJ.run("Threshold...");
		
		//Ask the user to do their own manual thresholding, and click ok when done
		new WaitForUserDialog("Manual thresholding", "Manually threshold the image then proceed").show();
	
		//Now we ask the user to check that the image foreground and background are correctly set
		//new WaitForUserDialog("Check image", "Make sure that vessels are in white on a black background, then proceed - to swap black/white tick the dark background box").show();
		new WaitForUserDialog("Check image", "Make sure dark background is checked, click apply, and uncheck calculate for each image").show();

		IJ.resetThreshold(avg);

		//If after thresholding the image has an inverted LUT, we flip it
		if(avg.isInvertedLut() == true) {
			IJ.run(avg, "Invert LUT", "");
		}

		//ImageStatistics stats;
		stats = new StackStatistics(avg);
		//stats=avg.getStatistics();
		if ((stats.histogram[0]+stats.histogram[255])!=stats.pixelCount){
		    thresholded=false;
		    new WaitForUserDialog("Thresholding Error", "Threshold Not Applied").show();
		} else {
			thresholded = true;
		}
	}

	//Check if the user is happy with the outcome of the manual thresholding
	boolean manualHappy = dialogUserApproval("Manual Thresholding", "Happy with the manual threshold?");

	//Return their choice
	return manualHappy;
	
}

//Function to check whether above threshold voxels are present in the input image
public static checkPresenceVoxels(image) {

	//Set all pixels with a grey value of >=1 to 255 then convert to a mask
	IJ.setRawThreshold(image, 1, 255, null);
	IJ.run(image, "Convert to Mask", "method=Default background=Dark");

	image.show();

	//Run the voxel counter - counts all the voxels in black - on the image so we can make sure that there are actually voxels in our object image
	IJ.run(image, "Voxel Counter", "");
			 
	//Get out the number of voxels counted as a double array, voxelCount
	ResultsTable rt = ResultsTable.getResultsTable();
	double[] voxelCount = rt.getColumnAsDoubles(0);
	
	//Create a boolean variable to show whether there are voxels or not in our image
	boolean exists = false;
	
	//voxelCount can be null if the column is empty (i.e. the code has errored), so if it isn't
	if(voxelCount!=null) {
	
		//Loop through the voxelCount array
		for(l=0; l<voxelCount.length; l++) {
				 	
			//If the current value is zero, we continue onwards
			if(voxelCount[l]==0) {
				continue;
				 	
			//If its not zero, we set exists to true and break out of our loop
			} else {
				IJ.log("Found non zero");
				exists = true;
				break;
			}
		}
	}
	
	return exists;
}

//Ask the user to select the directory where the isolectin images to be analysed are
DirectoryChooser userDir = new DirectoryChooser("Select The Isolectin Directory");

//Get the isolectin directory and its contained files/folders
String dirString = userDir.getDirectory();
File dir = new File(dirString);
String[] folderList = dir.list();

//Ask the user to select which function to use, where 0 is process and thresholding, and 1 is analyzing
String[] selection = new String[] {"Process and threshold images", "Automatically analyze images", "Re-Threshold Images"};

GenericDialog userInput = new GenericDialog("Function Selection");
userInput.addChoice("Test", selection, "Process and threshold images");
userInput.showDialog();

int functionChoice = userInput.getNextChoiceIndex();

//Looping through the isolectin directory files/folders
for (int i = 0; i < folderList.length; i++) {

 //Concatenate the file onto the original isolectin directory
 String fullString = dirString.concat(folderList[i]);
 File currFile = new File(fullString);

 IJ.log(fullString);

 //If this is a directory and if it contains an M then...
 if (currFile.isDirectory() == true && folderList[i].contains("M")) {

   //... get the list of files in that folder
   String[] imagesRaw = currFile.list();

	//If the user wants to re-threshold processed images
   if(functionChoice == 2) {

	//Create a variable where we store the directory to check if the image has already been processed
	File processed = new File(fullString + "/" + "Processed" + "/");

	//Get the processed folders
   	File[] topProc = processed.listFiles();

	//Loop through them
   	for(currFolder = 0; currFolder < topProc.length; currFolder++) {

		//Get the folder files
		File[] foldFiles = topProc[currFolder].listFiles();

		//Loop through them
		for(currImage = 0; currImage < foldFiles.length; currImage ++) {

			//Get the path of the current image, find out if it has thresholded in the name
			String imagePath = foldFiles[currImage].getAbsolutePath();
			thresh = imagePath.indexOf("Thresholded");

			//If it doesn't
			if(thresh == -1) {

				//Get the name without extension
				dot = foldFiles[currImage].getName().indexOf(".");
				realName = foldFiles[currImage].getName().substring(0, dot);

				//Create a file object that would point to the image's thresholded version
				File thresholdedCheck = new File(foldFiles[currImage].getParentFile() + File.separator + realName + " Thresholded.tif");

				//Check if the thresholded version exists
				if(!thresholdedCheck.exists()) {
				
					IJ.log("Checking for thresholding");
					IJ.log(imagePath);
					
					editImage = true;
					
					//Open the image, check if its thresholded or not
				   	raw = IJ.openImage(imagePath);
				   	thresholded = false;

				   	stats = new StackStatistics(raw);
					//stats=raw.getStatistics();
					if ((stats.histogram[0]+stats.histogram[255])!=stats.pixelCount){
					    thresholded = false;
					} else {
						thresholded = true;
					}
	
					//If its thresholded, save it as the name + " Thresholded" and ignore the thresholding code
					if(thresholded == true) {
						IJ.log("Image was already thresholded, saving with label");
						worked = IJ.saveAsTiff(raw, foldFiles[currImage].getParent() + File.separator + realName + " Thresholded");
						editImage = false;
					}
		
				
			   	 	//If not thresholded
		 			while (editImage == true) {
				   	
						//Create a backup
					   ImagePlus backup = raw.duplicate();
					
					   //Run the manual threshlding function on the input where manualHappy is a boolean about whether the user was happy with the manual thresholding
					   boolean manualHappy = manualThresholding(raw);
					
					   //If the user is happy, we'll try the skeleton editing function
					   if (manualHappy == true) {
	
						//Set editImage to false, close the backup, save the image as " Thresholded" and close
					    editImage = false;
					    backup.close();
	
					    IJ.log("Thresholded Image, Saving");
					    worked = IJ.saveAsTiff(raw, foldFiles[currImage].getParent() + File.separator + realName + " Thresholded");
					    raw.close();
					    if(worked == true) {
					    	IJ.log("Saved");
					    } else {
					    	IJ.log("Not saved");
					    }
					
					    //If the user wasn't happy with manual thresholding initially, replace the thresholded image with the backup
					   } else {
					    raw = replaceWithBackup(raw, backup);
					   }
		
		 			}
				}
			}
		}
   	}
   }


  //If the user has chosen to threshold the images
  if(functionChoice == 0) {

	//Create a string to store a choice of channels
	String[] channelSelection = {"1","2","3","4"};
	
	//Ask the user to choose which channels represent the vessels and isolectin staining
	GenericDialog userInput = new GenericDialog("Channel Selection");
	userInput.addChoice("Which channel are the vessels in?", channelSelection, "1");
	userInput.addChoice("Which channel is Isolectin in?", channelSelection, "2");
	userInput.showDialog();
	
	//Get channels chosen by the user
	int[] channelNumbs = new int[2];
	//[0] is vesselChannel, [1] is isoChannel
	
	for (j = 0; j < 2; j++) {
	 channelNumbs[j] = userInput.getNextChoiceIndex() + 1;
	}

	//Looping through those files
	for (int j = 0; j < imagesRaw.length; j++) {

		IJ.log(imagesRaw[j]);

		fileCheck = new File(fullString + "/" + imagesRaw[j]);
		if(fileCheck.isDirectory()==false) {
		
		dot = imagesRaw[j].indexOf(".");
		realName = imagesRaw[j].substring(0, dot);
		
	   //Create a variable where we store the directory to check if the image has already been processed
	   File processed = new File(fullString + "/" + "Processed" + "/" + realName + "/");

	   //If the image doesn't contain zproject or lif in its name and it hasn't been processed
	   if (!imagesRaw[j].contains("zproject") && !imagesRaw[j].contains("lif") && !processed.exists()) {
	
	    //Print the image name, open it, get its calibration, and if it hasn't been calibrated, ask the user to do so
	    String imagePath = fullString + "/" + imagesRaw[j];
	    raw = IJ.openImage(imagePath);
	    while (!raw.getCalibration().getUnit().equals("micron")) {
	     raw.show();
	     new WaitForUserDialog("Image Calibration", "Calibrate the image in microns").show();
	     raw.hide();
	    }

	    Calibration rawCal = raw.getCalibration();
	
	    //Get out the number of slices we'd need for a 40um thick substack of the tissue, as well as the number
	    //of slices in the image, then calculate the substack we need to make to take out the middle 40um of the image
	    double slicesToGrab = rawCal.getRawZ(40);
	    double rawSlices = (double) raw.getNSlices();
	    double beginningPoint = Math.floor((rawSlices - slicesToGrab) / 2);
	
	    //Create a substack based on those numbers and close the raw image
	    ImagePlus cutDown = new Duplicator().run(raw, 1, raw.getNChannels(), (int) beginningPoint, (int)(rawSlices - beginningPoint), 1, 1);
	    raw.close();
	
	    //Create arrays to store the image stacks of the split channels and then the imageplus objects we make from the stacks,
	    //as well as the titles we want to stick onto our imageplus objects
	    ImageStack[] imageStacks = new ImageStack[2];
	    ImagePlus[] images = new ImagePlus[2];
	    //[0] is vesselImage, [1] is isoImage
	    String[] titles = new String[] {"Vessels","Iso"};
	
	    //Create an imageplus array to store our processed imageplus objects
	    ImagePlus[] procImages = new ImagePlus[2];

		//Use the imageStacks array to split our images into different channels of a smaller size
	    for (k = 0; k < 2; k++) {
	     imageStacks[k] = new ChannelSplitter().getChannel(cutDown, channelNumbs[k]);
	     images[k] = new ImagePlus(titles[k], imageStacks[k]);   
	    }
	
		//Close our original cutDown image
	    cutDown.close();
	
	    //Assign variable names to the processed images
	    ImagePlus vesselImageProc = images[0];
	    ImagePlus isoImageProc = images[1];
	
		//Run the imageEditingFunction on our vessel image, and get out whether it was successful or not
	    vesselImageOutput = imageEditingFunction(vesselImageProc, "Vessels");

		//If it wasn't successful, we close all windows and create the processed directory so we know to skip this file next time and move onto the next file,
		//but if it was, we return the output image generated and move on
		ImagePlus vesselImageProc = checkEditingOutput(vesselImageOutput, processed);
		if(vesselImageOutput.get(1)==false) {
			continue;
		}

		vesselImageProc.hide();
		
		//Run the imageEditingFunction on our iso image, and get out whether it was successful or not, same process as the vessel image
	    isoImageOutput = imageEditingFunction(isoImageProc, "IsoLectin");
		ImagePlus isoImageProc = checkEditingOutput(isoImageOutput, processed);
		if(isoImageOutput.get(1) == false) {
			continue;
		}

		vesselImageProc.show();
		isoImageProc.show();

		//Store out output images in an ImagePlus array, and the names we want to save them as in a string array
	    ImagePlus[] outputImages = new ImagePlus[] {vesselImageProc, isoImageProc};
	    String[] saveName = new String[] {"Processed Vessels Thresholded", "Processed Iso Thresholded"};
	    	
		//Create the directory where we will save our processed images
		
		made = processed.mkdirs();
		//IJ.saveAsTiff(vesselImageProc, processed.getPath() + File.separator + "Processed Vessels");
		//IJ.saveAsTiff(isoImageProc, processed.getPath() + File.separator + "Processed Iso");

		//Calibrate our output images before saving them in the processed directory with their saveNames
	   for(k=0; k<outputImages.length; k++) {
	    	IJ.log(Integer.toString(k));
	   	IJ.log(outputImages[k].getTitle());
	   	IJ.log(processed.getPath() + "/" + saveName[k] + ".tif");
	   	outputImages[k].setCalibration(rawCal);
	   	saver = new FileSaver(outputImages[k]);
	   	IJ.saveAsTiff(outputImages[k], processed.getPath() + File.separator + saveName[k]);
	   	//IJ.saveAsTiff(outputImages[k],"C:/Users/Devin Clarke/Desktop/wow.tif");
	   	//saver.saveAsTiff("C:/Users/Devin Clarke/Desktop/wow.tif");
	   	//saver.saveAsTiff(processed.getPath() + "/" + saveName[k] + ".tif");
	    }

		ij.plugin.Commands.closeAll();
	
		//Close all images before proceeding to the next image in the directory
	    //WindowManager.closeAllWindows();
	
	   }
	  }
	}

	//If the user has chosen to automatically analyze the images
  	} else if (functionChoice == 1) {
	  
	  //Loop through all the images in the folder again
	  for(int j=0; j<imagesRaw.length; j++) {

	  	//Get out the start time for running this analysis function as a way to time it
	  	Calendar cal = Calendar.getInstance();
        Date date=cal.getTime();
        DateFormat dateFormat = new SimpleDateFormat("HH:mm:ss");
        String startDate=dateFormat.format(date);

        fileCheck = new File(fullString + "/" + imagesRaw[j]);
		if(fileCheck.isDirectory()==false) {
	    
	    dot = imagesRaw[j].indexOf(".");
		realName = imagesRaw[j].substring(0, dot);
		
	   //Create a variable where we store the directory to check if the image has already been processed
	   File processed = new File(fullString + "/" + "Processed" + "/" + realName + "/");

	   //IJ.log(processed.getPath());

	   if(processed.exists()) {
	   	IJ.log(processed.getPath() + " exists");
	   }
	     
	    //Create a variable where we store the directory to check if the image has actually been processed
	    File processedTwo = new File(fullString + "/" + "Processed/" + realName + "/Processed Vessels Thresholded.tif");
	    File processedThree = new File(fullString + "/" + "Processed/" + realName + "/Processed Iso Thresholded.tif");
		File saveCheck = new File(fullString + "/" + "Processed/" + realName + "/IB4Overlap.csv");

		IJ.log(saveCheck.getPath());
		
	   if(processedTwo.exists()) {
	   	IJ.log(processedTwo.getPath() + " exists");
	   }
	   if(processedThree.exists()) {
	   	IJ.log(processedThree.getPath() + " exists");
	   }
	   if(saveCheck.exists()) {
	   	IJ.log(saveCheck.getPath() + " exists");
	   }
		
	   //If the file has been processed but not analysed
		if(processed.exists() && processedTwo.exists() && processedThree.exists() && !(saveCheck.exists())) {
		
		 //Open the vessel and iso images
	     ImagePlus vesselImageProc = IJ.openImage(processed.getPath() + "/Processed Vessels Thresholded.tif");
	     ImagePlus isoImageProc = IJ.openImage(processed.getPath() + "/Processed Iso Thresholded.tif");

	     IJ.log(processed.getPath());

		 //Rename the thresholded vessels to "Thresholded" so that we can refer to it when using 3d manager
	     vesselImageProc.setTitle("Thresholded");

		 //Get out the calibration of the images for when we enlarge our ROIs
	     Calibration rawCal = vesselImageProc.getCalibration();
	     vesselImageProc.show();

		 String output = IJ.runMacro("run(\"3D Manager\"); Ext.Manager3D_SelectAll(); Ext.Manager3D_Delete(); selectWindow(\"Thresholded\"); Ext.Manager3D_Segment(1,255); forUse = getTitle(); selectWindow(forUse); Ext.Manager3D_AddImage(); Ext.Manager3D_Count(nb_obj); Ext.Manager3D_SelectAll(); Ext.Manager3D_Delete(); Ext.Manager3D_Close(); textForm = toString(nb_obj); return textForm;"); 
	   	 int nbObj = Integer.valueOf(output);
		 ImagePlus segmentedImage = WindowManager.getImage("Thresholded-3Dseg");
		 
		 IJ.log("Number of objects: " + output);
	
	     //Create a new results table to store our info
	     ResultsTable customRT = new ResultsTable();

		 //Create a new counter variable so we know where to add data into our results table
		 int objectsMeasured = 0;
	
	     //Loop through our objects
	     for (int k = 0; k < nbObj; k++) {
	     //for (int k = 0; k < 2; k++) {
	     	
	     	IJ.log("Analysing object number: " + Integer.toString(k));

	     	//Get out the current object from the segmented image and assign it to a new variable
	     	segmentedImage.show();
	    	IJ.run(segmentedImage, "Select Label(s)", "label(s)=" + (k + 1) + "");
	    	ImagePlus labelImage = IJ.getImage();
	    	segmentedImage.hide();

		 	//Create an imageplus array to store duplicates of the vesselImageProc object, and a string array to store the
		 	//names we'll call these duplicates
	     	ImagePlus[] duplicates = new ImagePlus[2];
	     	String[] titles = new String[] {"Skel","DmapPre"};
	
			//Duplicate the image and set its titles
	    	for (int l = 0; l < 2; l++) {
	     		duplicates[l] = labelImage.duplicate();
	     		duplicates[l].setTitle(titles[l]);
	    	}
	
			//Set objects to these duplicates
			ImagePlus dmapPre = duplicates[1];
			ImagePlus skeleton = duplicates[0];

			IJ.run(skeleton, "8-bit", "");
	
	    	//Skeletonise the other duplicate
	    	IJ.run(skeleton, "Skeletonize (2D/3D)", "");
	    	skeleton.setTitle("skel");
	    	skeleton.show();

	    	//Duplicate the object image so we can use this duplicate to check if there actually is an object in our image
	     	checkVol=skeleton.duplicate();

		 	//Return whether there is an object in our image 
	     	boolean exists = checkPresenceVoxels(checkVol);

	     	//Close the image we used to check for voxels
		 	closeImage(checkVol, false);

		 	//Add the object number to our results table
	     	customRT.setValue("Object number", objectsMeasured, Integer.toString(k+1));
	
		 	//Here we define the things we're measuring wrt our object, defaulted to NaNs so that if we can't fill them with actual values (i.e. if there is no object in our image),
		 	//when we print them they will print a NaN
		 	double meanValue = Double.NaN;
		 	double length = Double.NaN;
		 	double volumeChecking = Double.NaN;
		 	double overlappingVolume = Double.NaN;

		 	if(exists == false) {
		 		IJ.log("voxelCount is null");
		 		closeImage(labelImage, false);
		 	} else if(exists == true) {
			
			IJ.log("true");
			//Show the dmapPre duplicate as we have to in order to run 3D Distance Map
	    	dmapPre.show();
	
	    	//Generate the distance map and assign it to a variable and change its title
	    	IJ.run("3D Distance Map", "map=EDT image=" + dmapPre.getTitle() + " mask=Same threshold=1");
	    	ImagePlus dmap = IJ.getImage();
	    	dmap.setTitle("dmap");
	
	    	//Close the image used to generate it
	    	closeImage(dmapPre, false);
	    	dmap.show();

	    	IJ.run(skeleton, "Analyze Skeleton (2D/3D)", "prune=none show");
	    	ImagePlus toClose = WindowManager.getImage("Tagged skeleton");
	    	closeImage(toClose, false);

			String output = IJ.runMacro("run(\"3D Manager\"); Ext.Manager3D_SelectAll(); Ext.Manager3D_Delete(); selectWindow(\"skel\"); Ext.Manager3D_AddImage(); Ext.Manager3D_DeselectAll(); selectWindow(\"dmap\"); Ext.Manager3D_Quantif3D(0, \"Mean\", quantif); Ext.Manager3D_CloseResult(\"Q\"); Ext.Manager3D_SelectAll(); Ext.Manager3D_Delete(); Ext.Manager3D_Close(); textForm = toString(quantif); return textForm;"); 
		 	meanValue = Double.valueOf(output);

			IJ.selectWindow("Results");
			IJ.run("Close");
			
			IJ.renameResults("Branch information", "Results");
			ResultsTable bInfo = ResultsTable.getResultsTable();
			if(bInfo.getColumnAsDoubles(1) == null) {
				IJ.log("Results window is null");
		 		closeImage(labelImage, false);
		 		closeImage(dmap, false);
			} else {

			double [] lengthArr = bInfo.getColumnAsDoubles(1);

			length = 0;
			for (int l = 0; l < lengthArr.length; l++) {
				length += lengthArr[l];
			}
			
		 	IJ.log("Radius is " + IJ.d2s(meanValue) + " and Length is " + IJ.d2s(length));
		 	labelImage.show();

			//We now enlarge our object in 3D by 2 microns in all directions so we can measure the overlap of the isolectin staining within this radius of our vessel object
		    IJ.log("Enlarging object by 2 microns");

			//We use the maximum fast filter in 3D on our object image and its calibration values to create a new image of our object enlarged and assign this to a variable
		    IJ.run(labelImage, "3D Fast Filters","filter=Maximum radius_x_unit=2 radius_y_unit=2 radius_z_unit=2 algorithm=Isotropic Nb_cpus=4");
		    ImagePlus enlargedImage = WindowManager.getImage("Maximum");  

			ImageCalculator ic = new ImageCalculator();
			//Here we find the difference pixels between the enlarged and non-enlarged object and assign this to a variable
		    ImagePlus diffImage = ic.run("Difference create stack", enlargedImage, labelImage);
		    diffImage.show();
		    diffImage.setTitle("Diff");
		
		    IJ.log("Finding volume of enlarged object");

			String output = IJ.runMacro("run(\"3D Manager\"); Ext.Manager3D_SelectAll(); Ext.Manager3D_Delete(); selectWindow(\"Diff\"); Ext.Manager3D_AddImage(); Ext.Manager3D_Measure3D(0, \"Vol\", measure); Ext.Manager3D_Close(); asString = toString(measure); return asString;");
		    volumeChecking = Double.valueOf(output);

		    //Close the enlarged image, and object image now we're done with them
  			closeImage(enlargedImage, false);
  			closeImage(labelImage, false);
			
		    IJ.log("Volume of enlarged object: " + output);
		    IJ.log("Finding pixels from isolectin within our ROI");
		
		    //Calculate the isolectin staining that is within our ROI to check and assign that to a new variable
		    ImageCalculator ic = new ImageCalculator();
		    ImagePlus IB4Overlap = ic.run("AND create stack", isoImageProc, diffImage);
		    IB4Overlap.show();
		    IB4Overlap.setTitle("IB4Overlap");
		
			IJ.log("Getting volume of pixels within ROI");

			//Duplicate the object image so we can use this duplicate to check if there actually is an object in our image
	     	checkVol=IB4Overlap.duplicate();

		 	//Return whether there is an object in our image 
	     	boolean exists = checkPresenceVoxels(checkVol);

	     	//Close the image we used to check for voxels
		 	closeImage(checkVol, false);
		 	
			//Up to here now
			//Basically, length and radius seems to work properly now, just need to test out this englargement business

			if(exists == true) {
	
			 //Use the 3D manager to get out the volume within this ROI
		     String output = IJ.runMacro("run(\"3D Manager\"); Ext.Manager3D_SelectAll(); Ext.Manager3D_Delete(); selectWindow(\"IB4Overlap\"); Ext.Manager3D_AddImage();  Ext.Manager3D_Measure3D(0, \"Vol\", measure); Ext.Manager3D_Close(); asString = toString(measure); return asString;");
		     overlappingVolume = Double.valueOf(output);
		     IJ.log("Overlapping pixels: " + output);

			} else {
				IJ.log("No overlapping pixels");

			}

			 //Close the overlap image since we're done with it now
		     closeImage(IB4Overlap, false);
		     closeImage(diffImage, false);
		     closeImage(dmap, false);

		 }
		 	}
	
	     //Fill our results table with the values of interest
	     customRT.setValue("Radii", objectsMeasured, meanValue);
	     customRT.setValue("Length", objectsMeasured, length);
	     customRT.setValue("Volume Around", objectsMeasured, volumeChecking);
	     customRT.setValue("Volume Occupied", objectsMeasured, overlappingVolume);
	     customRT.setValue("Percentage Occupied", objectsMeasured, overlappingVolume / volumeChecking);

		 //Increase the value of our objectsMeasures counter
	     objectsMeasured++;
	
	     customRT.show("Testing");

	     closeImage(skeleton, false);
	
	    }
	
	    //Save as a results table labelled with the same name as our image
	    customRT.save(processed.getPath() + "/IB4Overlap.csv");
	    customRT.reset();
	
	    IJ.log("Results saved");
	
	    //Close all our windows
	    closeImage(isoImageProc, false);
	    closeImage(vesselImageProc, false);

		//Get out the time we finished processing this image and print it
	    Calendar cal = Calendar.getInstance();
        Date date=cal.getTime();
        DateFormat dateFormat = new SimpleDateFormat("HH:mm:ss");
        String endDate=dateFormat.format(date);

        IJ.log("Time at start of image" + startDate);
        IJ.log("Time at end of image" + endDate);

		}
	   }
	  }
	 }
	}
   }

